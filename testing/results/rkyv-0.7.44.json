[
  {
    "built_with_features": "alloc",
    "command": {
      "args": [
        "build",
        "--target",
        "thumbv7m-none-eabi",
        "--no-default-features",
        "--features",
        "alloc"
      ],
      "code": 101,
      "stderr": "   Compiling rkyv v0.7.44 (/Users/graysonnocera/Downloads/695-Project/dataset/nostd-failed-crates/crates/rkyv-0.7.44)\nerror: one of [\"size_16\", \"size_32\", or \"size_64\"] features must be enabled\n   --> src/macros.rs:114:1\n    |\n114 | core::compile_error!(r#\"one of [\"size_16\", \"size_32\", or \"size_64\"] features must be enabled\"#);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n   --> src/lib.rs:723:23\n    |\n723 | pub type FixedUsize = pick_size_type!(u16, u32, u64);\n    |                       ^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n   --> src/lib.rs:728:23\n    |\n728 | pub type FixedIsize = pick_size_type!(i16, i32, i64);\n    |                       ^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n   --> src/with/core.rs:286:35\n    |\n286 | type ArchivedOptionNonZeroUsize = pick_size_type!(\n    |                                   ^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n   --> src/with/core.rs:285:26\n    |\n285 | type FixedNonZeroUsize = pick_size_type!(NonZeroU16, NonZeroU32, NonZeroU64);\n    |                          ^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n   --> src/with/core.rs:234:35\n    |\n234 | type ArchivedOptionNonZeroIsize = pick_size_type!(\n    |                                   ^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n   --> src/with/core.rs:233:26\n    |\n233 | type FixedNonZeroIsize = pick_size_type!(NonZeroI16, NonZeroI32, NonZeroI64);\n    |                          ^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n   --> src/with/atomic.rs:144:29\n    |\n144 |     type FixedAtomicIsize = pick_size_type!(AtomicI16, AtomicI32, ());\n    |                             ^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n  --> src/with/atomic.rs:91:29\n   |\n91 |     type FixedAtomicUsize = pick_size_type!(AtomicU16, AtomicU32, ());\n   |                             ^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n   --> src/impls/core/primitive.rs:315:26\n    |\n315 | type FixedNonZeroIsize = pick_size_type!(NonZeroI16, NonZeroI32, NonZeroI64);\n    |                          ^^^^^^^^^^^^^^\n\nerror: cannot find macro `pick_size_type` in this scope\n   --> src/impls/core/primitive.rs:285:26\n    |\n285 | type FixedNonZeroUsize = pick_size_type!(NonZeroU16, NonZeroU32, NonZeroU64);\n    |                          ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n --> src/impls/alloc/rc.rs:8:33\n  |\n8 | #[cfg(all(not(feature = \"std\"), has_atomics))]\n  |                                 ^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n  --> src/impls/alloc/rc.rs:13:28\n   |\n13 | #[cfg(all(feature = \"std\", has_atomics))]\n   |                            ^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/alloc/rc.rs:130:7\n    |\n130 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/alloc/rc.rs:133:7\n    |\n133 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/alloc/rc.rs:141:7\n    |\n141 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/alloc/rc.rs:152:7\n    |\n152 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/alloc/rc.rs:164:7\n    |\n164 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/alloc/rc.rs:183:7\n    |\n183 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/alloc/rc.rs:197:7\n    |\n197 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/alloc/rc.rs:213:7\n    |\n213 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/alloc/rc.rs:230:7\n    |\n230 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n --> src/impls/core/primitive.rs:2:7\n  |\n2 | #[cfg(has_atomics)]\n  |       ^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n --> src/impls/core/primitive.rs:7:7\n  |\n7 | #[cfg(has_atomics_64)]\n  |       ^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n  --> src/impls/core/primitive.rs:77:7\n   |\n77 | #[cfg(has_atomics)]\n   |       ^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:141:7\n    |\n141 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:143:7\n    |\n143 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:145:7\n    |\n145 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:171:7\n    |\n171 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:173:7\n    |\n173 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n   --> src/impls/core/primitive.rs:175:7\n    |\n175 | #[cfg(has_atomics_64)]\n    |       ^^^^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:177:7\n    |\n177 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:179:7\n    |\n179 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n   --> src/impls/core/primitive.rs:181:7\n    |\n181 | #[cfg(has_atomics_64)]\n    |       ^^^^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:345:7\n    |\n345 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:356:7\n    |\n356 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:364:7\n    |\n364 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:374:7\n    |\n374 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:385:7\n    |\n385 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n   --> src/impls/core/primitive.rs:393:7\n    |\n393 | #[cfg(has_atomics)]\n    |       ^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics`\n --> src/with/mod.rs:8:7\n  |\n8 | #[cfg(has_atomics)]\n  |       ^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n --> src/with/atomic.rs:8:7\n  |\n8 | #[cfg(has_atomics_64)]\n  |       ^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n  --> src/with/atomic.rs:74:7\n   |\n74 | #[cfg(has_atomics_64)]\n   |       ^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n  --> src/with/atomic.rs:78:7\n   |\n78 | #[cfg(has_atomics_64)]\n   |       ^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n  --> src/with/atomic.rs:85:11\n   |\n85 | #[cfg(any(has_atomics_64, not(feature = \"size_64\")))]\n   |           ^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n   --> src/with/atomic.rs:138:11\n    |\n138 | #[cfg(any(has_atomics_64, not(feature = \"size_64\")))]\n    |           ^^^^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n  --> src/with/atomic.rs:90:15\n   |\n90 |     #[cfg(not(has_atomics_64))]\n   |               ^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n  --> src/with/atomic.rs:92:11\n   |\n92 |     #[cfg(has_atomics_64)]\n   |           ^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n   --> src/with/atomic.rs:143:15\n    |\n143 |     #[cfg(not(has_atomics_64))]\n    |               ^^^^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `has_atomics_64`\n   --> src/with/atomic.rs:145:11\n    |\n145 |     #[cfg(has_atomics_64)]\n    |           ^^^^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(has_atomics_64)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(has_atomics_64)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nerror[E0080]: evaluation of constant value failed\n  --> src/string/repr.rs:19:36\n   |\n19 | pub const INLINE_CAPACITY: usize = mem::size_of::<OutOfLineRepr>() - 1;\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempt to compute `0_usize - 1_usize`, which would overflow\n\nnote: erroneous constant encountered\n  --> src/string/repr.rs:24:17\n   |\n24 |     bytes: [u8; INLINE_CAPACITY],\n   |                 ^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:96:25\n    |\n96  |         type Archived = Archived<With<FixedAtomicUsize, Self>>;\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:100:9\n    |\n100 | /         unsafe fn resolve_with(\n101 | |             field: &AtomicUsize,\n102 | |             _: usize,\n103 | |             _: Self::Resolver,\n104 | |             out: *mut Self::Archived,\n105 | |         ) {\n    | |_________^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:121:25\n    |\n121 |         DeserializeWith<<Self as ArchiveWith<FixedAtomicUsize>>::Archived, AtomicUsize, D>\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ArchiveWith<()>` is not implemented for `Atomic`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:125:9\n    |\n125 | /         fn deserialize_with(\n126 | |             field: &<Self as ArchiveWith<FixedAtomicUsize>>::Archived,\n127 | |             _: &mut D,\n128 | |         ) -> Result<AtomicUsize, D::Error> {\n    | |__________________________________________^ the trait `ArchiveWith<()>` is not implemented for `Atomic`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:149:25\n    |\n149 |         type Archived = Archived<With<FixedAtomicIsize, Self>>;\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:153:9\n    |\n153 | /         unsafe fn resolve_with(\n154 | |             field: &AtomicIsize,\n155 | |             _: usize,\n156 | |             _: Self::Resolver,\n157 | |             out: *mut Self::Archived,\n158 | |         ) {\n    | |_________^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:173:32\n    |\n173 |     impl<D: Fallible + ?Sized> DeserializeWith<Archived<With<AtomicIsize, Self>>, AtomicIsize, D>\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:177:9\n    |\n177 | /         fn deserialize_with(\n178 | |             field: &Archived<With<AtomicIsize, Self>>,\n179 | |             _: &mut D,\n180 | |         ) -> Result<AtomicIsize, D::Error> {\n    | |__________________________________________^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:104:18\n    |\n104 |             out: *mut Self::Archived,\n    |                  ^^^^^^^^^^^^^^^^^^^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:126:21\n    |\n126 |             field: &<Self as ArchiveWith<FixedAtomicUsize>>::Archived,\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ArchiveWith<()>` is not implemented for `Atomic`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:157:18\n    |\n157 |             out: *mut Self::Archived,\n    |                  ^^^^^^^^^^^^^^^^^^^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:178:20\n    |\n178 |             field: &Archived<With<AtomicIsize, Self>>,\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<T, ()>`, but its trait bounds were not satisfied\n   --> src/boxed.rs:19:27\n    |\n19  |         unsafe { &*self.0.as_ptr() }\n    |                           ^^^^^^ method cannot be called on `RelPtr<T, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_mut_ptr` exists for struct `RelPtr<T, ()>`, but its trait bounds were not satisfied\n   --> src/boxed.rs:25:55\n    |\n25  |         unsafe { self.map_unchecked_mut(|s| &mut *s.0.as_mut_ptr()) }\n    |                                                       ^^^^^^^^^^ method cannot be called on `RelPtr<T, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_mut_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the function or associated item `resolve_emplace_from_raw_parts` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/boxed.rs:77:17\n    |\n77  |         RelPtr::resolve_emplace_from_raw_parts(\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `resolve_emplace_from_raw_parts` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `is_null` exists for struct `RelPtr<T, ()>`, but its trait bounds were not satisfied\n   --> src/boxed.rs:88:16\n    |\n88  |         self.0.is_null()\n    |                ^^^^^^^ method cannot be called on `RelPtr<T, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `is_null` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the function or associated item `emplace_null` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/boxed.rs:132:17\n    |\n132 |         RelPtr::emplace_null(pos + fp, fo);\n    |                 ^^^^^^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `emplace_null` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:304:37\n    |\n304 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O>\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0605]: non-primitive cast: `()` as `usize`\n   --> src/collections/btree_map/mod.rs:101:9\n    |\n101 |         from_archived!(*archived) as usize\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: the function or associated item `emplace` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/collections/btree_map/mod.rs:127:17\n    |\n127 |         RelPtr::emplace(pos + fp, self.pos.unwrap_or(pos + fp), fo);\n    |                 ^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `emplace` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:273:12\n    |\n273 | impl<T, O: Offset> RelPtr<T, O> {\n    |            ^^^^^^  ------------\n    |            |\n    |            unsatisfied trait bound introduced here\n\nerror[E0599]: the function or associated item `emplace` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/collections/btree_map/mod.rs:142:17\n    |\n142 |         RelPtr::emplace(pos + fp, resolver.0, fo);\n    |                 ^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `emplace` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:273:12\n    |\n273 | impl<T, O: Offset> RelPtr<T, O> {\n    |            ^^^^^^  ------------\n    |            |\n    |            unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<NodeHeader, ()>`, but its trait bounds were not satisfied\n   --> src/collections/btree_map/mod.rs:215:45\n    |\n215 |             let root = unsafe { &*self.root.as_ptr() };\n    |                                             ^^^^^^ method cannot be called on `RelPtr<NodeHeader, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<NodeHeader, ()>`, but its trait bounds were not satisfied\n   --> src/collections/btree_map/mod.rs:224:56\n    |\n224 |                 let next = unsafe { &*inner.header.ptr.as_ptr() };\n    |                                                        ^^^^^^ method cannot be called on `RelPtr<NodeHeader, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<NodeHeader, ()>`, but its trait bounds were not satisfied\n   --> src/collections/btree_map/mod.rs:280:66\n    |\n280 | ...                   Ok(i) => unsafe { &*node.tail[i].ptr.as_ptr() },\n    |                                                            ^^^^^^ method cannot be called on `RelPtr<NodeHeader, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<NodeHeader, ()>`, but its trait bounds were not satisfied\n   --> src/collections/btree_map/mod.rs:283:64\n    |\n283 | ...                   unsafe { &*node.header.ptr.as_ptr() }\n    |                                                  ^^^^^^ method cannot be called on `RelPtr<NodeHeader, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<NodeHeader, ()>`, but its trait bounds were not satisfied\n   --> src/collections/btree_map/mod.rs:285:69\n    |\n285 | ...                   unsafe { &*node.tail[i - 1].ptr.as_ptr() }\n    |                                                       ^^^^^^ method cannot be called on `RelPtr<NodeHeader, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0605]: non-primitive cast: `()` as `usize`\n   --> src/collections/btree_map/mod.rs:335:9\n    |\n335 |         from_archived!(self.len) as usize\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: the function or associated item `emplace` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/collections/btree_map/mod.rs:364:17\n    |\n364 |         RelPtr::emplace(pos + fp, resolver.root_pos, fo);\n    |                 ^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `emplace` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:273:12\n    |\n273 | impl<T, O: Offset> RelPtr<T, O> {\n    |            ^^^^^^  ------------\n    |            |\n    |            unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<NodeHeader, ()>`, but its trait bounds were not satisfied\n   --> src/collections/btree_map/mod.rs:655:72\n    |\n655 |                     self.leaf = NonNull::new_unchecked(leaf.header.ptr.as_ptr() as *mut _);\n    |                                                                        ^^^^^^ method cannot be called on `RelPtr<NodeHeader, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0605]: non-primitive cast: `()` as `usize`\n  --> src/collections/hash_index/mod.rs:28:9\n   |\n28 |         from_archived!(self.len) as usize\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<u32, ()>`, but its trait bounds were not satisfied\n   --> src/collections/hash_index/mod.rs:50:54\n    |\n50  |         unsafe { slice::from_raw_parts(self.displace.as_ptr(), self.len()) }\n    |                                                      ^^^^^^ method cannot be called on `RelPtr<u32, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the function or associated item `emplace` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/collections/hash_index/mod.rs:109:17\n    |\n109 |         RelPtr::emplace(pos + fp, resolver.displace_pos, fo);\n    |                 ^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `emplace` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:273:12\n    |\n273 | impl<T, O: Offset> RelPtr<T, O> {\n    |            ^^^^^^  ------------\n    |            |\n    |            unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<Entry<K, V>, ()>`, but its trait bounds were not satisfied\n   --> src/collections/hash_map/mod.rs:48:24\n    |\n48  |         &*self.entries.as_ptr().add(index)\n    |                        ^^^^^^ method cannot be called on `RelPtr<Entry<K, V>, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_mut_ptr` exists for struct `RelPtr<Entry<K, V>, ()>`, but its trait bounds were not satisfied\n   --> src/collections/hash_map/mod.rs:53:28\n    |\n53  |         &mut *self.entries.as_mut_ptr().add(index)\n    |                            ^^^^^^^^^^ method cannot be called on `RelPtr<Entry<K, V>, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_mut_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<Entry<K, V>, ()>`, but its trait bounds were not satisfied\n   --> src/collections/hash_map/mod.rs:191:35\n    |\n191 |         RawIter::new(self.entries.as_ptr().cast(), self.len())\n    |                                   ^^^^^^ method cannot be called on `RelPtr<Entry<K, V>, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_mut_ptr` exists for struct `RelPtr<Entry<K, V>, ()>`, but its trait bounds were not satisfied\n   --> src/collections/hash_map/mod.rs:198:46\n    |\n198 |             RawIterPin::new(hash_map.entries.as_mut_ptr().cast(), hash_map.len())\n    |                                              ^^^^^^^^^^ method cannot be called on `RelPtr<Entry<K, V>, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_mut_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the function or associated item `emplace` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/collections/hash_map/mod.rs:260:17\n    |\n260 |         RelPtr::emplace(pos + fp, resolver.entries_pos, fo);\n    |                 ^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `emplace` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:273:12\n    |\n273 | impl<T, O: Offset> RelPtr<T, O> {\n    |            ^^^^^^  ------------\n    |            |\n    |            unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<(), ()>`, but its trait bounds were not satisfied\n   --> src/collections/index_map/mod.rs:29:37\n    |\n29  |         from_archived!(*self.pivots.as_ptr().add(index)) as usize\n    |                                     ^^^^^^ method cannot be called on `RelPtr<(), ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<Entry<K, V>, ()>`, but its trait bounds were not satisfied\n   --> src/collections/index_map/mod.rs:34:24\n    |\n34  |         &*self.entries.as_ptr().add(index)\n    |                        ^^^^^^ method cannot be called on `RelPtr<Entry<K, V>, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<Entry<K, V>, ()>`, but its trait bounds were not satisfied\n   --> src/collections/index_map/mod.rs:147:35\n    |\n147 |         RawIter::new(self.entries.as_ptr().cast(), self.len())\n    |                                   ^^^^^^ method cannot be called on `RelPtr<Entry<K, V>, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the function or associated item `emplace` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/collections/index_map/mod.rs:208:17\n    |\n208 |         RelPtr::emplace(pos + fp, resolver.pivots_pos, fo);\n    |                 ^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `emplace` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:273:12\n    |\n273 | impl<T, O: Offset> RelPtr<T, O> {\n    |            ^^^^^^  ------------\n    |            |\n    |            unsatisfied trait bound introduced here\n\nerror[E0599]: the function or associated item `emplace` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/collections/index_map/mod.rs:211:17\n    |\n211 |         RelPtr::emplace(pos + fp, resolver.entries_pos, fo);\n    |                 ^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `emplace` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:273:12\n    |\n273 | impl<T, O: Offset> RelPtr<T, O> {\n    |            ^^^^^^  ------------\n    |            |\n    |            unsatisfied trait bound introduced here\n\nerror[E0605]: non-primitive cast: `usize` as `()`\n   --> src/impls/core/primitive.rs:239:32\n    |\n239 |         out.write(to_archived!(*self as FixedUsize));\n    |                                ^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `()` as `usize`\n   --> src/impls/core/primitive.rs:253:12\n    |\n253 |         Ok(from_archived!(*self) as usize)\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `isize` as `()`\n   --> src/impls/core/primitive.rs:265:32\n    |\n265 |         out.write(to_archived!(*self as FixedIsize));\n    |                                ^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `()` as `isize`\n   --> src/impls/core/primitive.rs:279:12\n    |\n279 |         Ok(from_archived!(*self) as isize)\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: no function or associated item named `new_unchecked` found for unit type `()` in the current scope\n   --> src/impls/core/primitive.rs:293:51\n    |\n293 |         out.write(to_archived!(FixedNonZeroUsize::new_unchecked(\n    |                                                   ^^^^^^^^^^^^^ function or associated item not found in `()`\n\nerror[E0605]: non-primitive cast: `usize` as `()`\n   --> src/impls/core/primitive.rs:294:13\n    |\n294 |             self.get() as FixedUsize\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: no method named `get` found for unit type `()` in the current scope\n    --> src/impls/core/primitive.rs:309:71\n     |\n309  |         Ok(unsafe { NonZeroUsize::new_unchecked(from_archived!(*self).get() as usize) })\n     |                                                                       ^^^\n     |\nhelp: there is a method `ge` with a similar name, but with different arguments\n    --> /Users/graysonnocera/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs:1232:5\n     |\n1232 |     fn ge(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new_unchecked` found for unit type `()` in the current scope\n   --> src/impls/core/primitive.rs:323:51\n    |\n323 |         out.write(to_archived!(FixedNonZeroIsize::new_unchecked(\n    |                                                   ^^^^^^^^^^^^^ function or associated item not found in `()`\n\nerror[E0605]: non-primitive cast: `isize` as `()`\n   --> src/impls/core/primitive.rs:324:13\n    |\n324 |             self.get() as FixedIsize\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: no method named `get` found for unit type `()` in the current scope\n    --> src/impls/core/primitive.rs:339:71\n     |\n339  |         Ok(unsafe { NonZeroIsize::new_unchecked(from_archived!(*self).get() as isize) })\n     |                                                                       ^^^\n     |\nhelp: there is a method `ge` with a similar name, but with different arguments\n    --> /Users/graysonnocera/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs:1232:5\n     |\n1232 |     fn ge(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0605]: non-primitive cast: `usize` as `()`\n   --> src/impls/core/primitive.rs:352:32\n    |\n352 |         out.write(to_archived!(self.load(Ordering::Relaxed) as FixedUsize));\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `()` as `usize`\n   --> src/impls/core/primitive.rs:368:12\n    |\n368 |         Ok((from_archived!(*self) as usize).into())\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `isize` as `()`\n   --> src/impls/core/primitive.rs:381:32\n    |\n381 |         out.write(to_archived!(self.load(Ordering::Relaxed) as FixedIsize));\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `()` as `isize`\n   --> src/impls/core/primitive.rs:397:12\n    |\n397 |         Ok((from_archived!(*self) as isize).into())\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `usize` as `()`\n   --> src/impls/core/mod.rs:190:32\n    |\n190 |         out.write(to_archived!(ptr_meta::metadata(self) as FixedUsize));\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `()` as `usize`\n   --> src/impls/core/mod.rs:199:9\n    |\n199 |         from_archived!(*archived) as usize\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `usize` as `()`\n   --> src/impls/core/mod.rs:326:32\n    |\n326 |         out.write(to_archived!(ptr_meta::metadata(self) as FixedUsize))\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<T, ()>`, but its trait bounds were not satisfied\n   --> src/rc/mod.rs:24:27\n    |\n24  |         unsafe { &*self.0.as_ptr() }\n    |                           ^^^^^^ method cannot be called on `RelPtr<T, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_mut_ptr` exists for struct `RelPtr<T, ()>`, but its trait bounds were not satisfied\n   --> src/rc/mod.rs:35:46\n    |\n35  |         self.map_unchecked_mut(|s| &mut *s.0.as_mut_ptr())\n    |                                              ^^^^^^^^^^ method cannot be called on `RelPtr<T, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_mut_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `base` exists for struct `RelPtr<T, ()>`, but its trait bounds were not satisfied\n   --> src/rc/mod.rs:153:35\n    |\n153 |         fmt::Pointer::fmt(&self.0.base(), f)\n    |                                   ^^^^ method cannot be called on `RelPtr<T, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `base` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for unit type `()` in the current scope\n  --> src/string/repr.rs:48:21\n   |\n48 |         FixedIsize::from_le_bytes(self.out_of_line.offset) as isize\n   |                     ^^^^^^^^^^^^^ function or associated item not found in `()`\n   |\nhelp: there is an associated function `from_iter` with a similar name\n   |\n48 |         FixedIsize::from_iter(self.out_of_line.offset) as isize\n   |                     ~~~~~~~~~\n\nerror[E0605]: non-primitive cast: `()` as `usize`\n  --> src/string/repr.rs:86:17\n   |\n86 |                 from_archived!(self.out_of_line.len) as usize\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: no method named `to_le_bytes` found for unit type `()` in the current scope\n   --> src/string/repr.rs:158:46\n    |\n158 |         *out_offset = (offset as FixedIsize).to_le_bytes();\n    |                                              ^^^^^^^^^^^ method not found in `()`\n\nerror[E0605]: non-primitive cast: `usize` as `()`\n   --> src/string/repr.rs:154:36\n    |\n154 |         out_len.write(to_archived!(value.len() as FixedUsize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `isize` as `()`\n   --> src/string/repr.rs:158:23\n    |\n158 |         *out_offset = (offset as FixedIsize).to_le_bytes();\n    |                       ^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: the method `as_ptr` exists for reference `&RelPtr<<T as ArchiveUnsized>::Archived, ()>`, but its trait bounds were not satisfied\n   --> src/util/mod.rs:107:15\n    |\n107 |     &*rel_ptr.as_ptr()\n    |               ^^^^^^ method cannot be called on `&RelPtr<<T as ArchiveUnsized>::Archived, ()>` due to unsatisfied trait bounds\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_mut_ptr` exists for mutable reference `&mut RelPtr<<T as ArchiveUnsized>::Archived, ()>`, but its trait bounds were not satisfied\n   --> src/util/mod.rs:132:38\n    |\n132 |     Pin::new_unchecked(&mut *rel_ptr.as_mut_ptr())\n    |                                      ^^^^^^^^^^ method cannot be called on `&mut RelPtr<<T as ArchiveUnsized>::Archived, ()>` due to unsatisfied trait bounds\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the method `as_ptr` exists for struct `RelPtr<T, ()>`, but its trait bounds were not satisfied\n   --> src/vec/mod.rs:33:18\n    |\n33  |         self.ptr.as_ptr()\n    |                  ^^^^^^ method cannot be called on `RelPtr<T, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0605]: non-primitive cast: `()` as `usize`\n  --> src/vec/mod.rs:39:9\n   |\n39 |         from_archived!(self.len) as usize\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0599]: the method `as_mut_ptr` exists for struct `RelPtr<T, ()>`, but its trait bounds were not satisfied\n   --> src/vec/mod.rs:58:78\n    |\n58  |             self.map_unchecked_mut(|s| core::slice::from_raw_parts_mut(s.ptr.as_mut_ptr(), s.len()))\n    |                                                                              ^^^^^^^^^^ method cannot be called on `RelPtr<T, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ method `as_mut_ptr` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nerror[E0599]: the function or associated item `emplace` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/vec/mod.rs:99:17\n    |\n99  |         RelPtr::emplace(pos + fp, resolver.pos, fo);\n    |                 ^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `emplace` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:273:12\n    |\n273 | impl<T, O: Offset> RelPtr<T, O> {\n    |            ^^^^^^  ------------\n    |            |\n    |            unsatisfied trait bound introduced here\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:105:11\n    |\n105 |           ) {\n    |  ___________^\n106 | |             (*out).store(\n107 | |                 field.load(Ordering::Relaxed) as FixedUsize,\n108 | |                 Ordering::Relaxed,\n109 | |             );\n110 | |         }\n    | |_________^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0605]: non-primitive cast: `usize` as `()`\n   --> src/with/atomic.rs:107:17\n    |\n107 |                 field.load(Ordering::Relaxed) as FixedUsize,\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:128:44\n    |\n128 |           ) -> Result<AtomicUsize, D::Error> {\n    |  ____________________________________________^\n129 | |             Ok((field.load(Ordering::Relaxed) as usize).into())\n130 | |         }\n    | |_________^ the trait `ArchiveWith<()>` is not implemented for `Atomic`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\n\nerror[E0282]: type annotations needed\n   --> src/with/atomic.rs:129:23\n    |\n129 |             Ok((field.load(Ordering::Relaxed) as usize).into())\n    |                       ^^^^ cannot infer type\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:158:11\n    |\n158 |           ) {\n    |  ___________^\n159 | |             (*out).store(\n160 | |                 field.load(Ordering::Relaxed) as FixedIsize,\n161 | |                 Ordering::Relaxed,\n162 | |             );\n163 | |         }\n    | |_________^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0605]: non-primitive cast: `isize` as `()`\n   --> src/with/atomic.rs:160:17\n    |\n160 |                 field.load(Ordering::Relaxed) as FixedIsize,\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0277]: the trait bound `Atomic: ArchiveWith<()>` is not satisfied\n   --> src/with/atomic.rs:180:44\n    |\n180 |           ) -> Result<AtomicIsize, D::Error> {\n    |  ____________________________________________^\n181 | |             Ok((field.load(Ordering::Relaxed) as isize).into())\n182 | |         }\n    | |_________^ the trait `ArchiveWith<()>` is not implemented for `Atomic`, which is required by `With<(), Atomic>: Archive`\n    |\n    = help: the following other types implement trait `ArchiveWith<F>`:\n              `Atomic` implements `ArchiveWith<AtomicBool>`\n              `Atomic` implements `ArchiveWith<AtomicI16>`\n              `Atomic` implements `ArchiveWith<AtomicI32>`\n              `Atomic` implements `ArchiveWith<AtomicI8>`\n              `Atomic` implements `ArchiveWith<AtomicIsize>`\n              `Atomic` implements `ArchiveWith<AtomicU16>`\n              `Atomic` implements `ArchiveWith<AtomicU32>`\n              `Atomic` implements `ArchiveWith<AtomicU8>`\n              `Atomic` implements `ArchiveWith<AtomicUsize>`\nnote: required for `With<(), Atomic>` to implement `Archive`\n   --> src/with/mod.rs:189:36\n    |\n189 | impl<F: ?Sized, W: ArchiveWith<F>> Archive for With<F, W> {\n    |                    --------------  ^^^^^^^     ^^^^^^^^^^\n    |                    |\n    |                    unsatisfied trait bound introduced here\n\nerror[E0282]: type annotations needed\n   --> src/with/atomic.rs:181:23\n    |\n181 |             Ok((field.load(Ordering::Relaxed) as isize).into())\n    |                       ^^^^ cannot infer type\n\nerror[E0599]: no function or associated item named `resolve_from_option` found for unit type `()` in the current scope\n   --> src/with/core.rs:252:37\n    |\n252 |         ArchivedOptionNonZeroIsize::resolve_from_option(f, out);\n    |                                     ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `()`\n\nerror[E0599]: the method `as_ref` exists for reference `&()`, but its trait bounds were not satisfied\n   --> src/with/core.rs:274:14\n    |\n273 |           Ok(field\n    |  ____________-\n274 | |             .as_ref()\n    | |             -^^^^^^ method cannot be called on `&()` due to unsatisfied trait bounds\n    | |_____________|\n    |\n    |\n    = note: the following trait bounds were not satisfied:\n            `(): AsRef<_>`\n            which is required by `&(): AsRef<_>`\n\nerror[E0599]: no function or associated item named `resolve_from_option` found for unit type `()` in the current scope\n   --> src/with/core.rs:304:37\n    |\n304 |         ArchivedOptionNonZeroUsize::resolve_from_option(f, out);\n    |                                     ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `()`\n\nerror[E0599]: the method `as_ref` exists for reference `&()`, but its trait bounds were not satisfied\n   --> src/with/core.rs:326:14\n    |\n325 |           Ok(field\n    |  ____________-\n326 | |             .as_ref()\n    | |             -^^^^^^ method cannot be called on `&()` due to unsatisfied trait bounds\n    | |_____________|\n    |\n    |\n    = note: the following trait bounds were not satisfied:\n            `(): AsRef<_>`\n            which is required by `&(): AsRef<_>`\n\nerror[E0599]: the function or associated item `resolve_emplace` exists for struct `RelPtr<_, ()>`, but its trait bounds were not satisfied\n   --> src/lib.rs:675:17\n    |\n675 |         RelPtr::resolve_emplace(from, to, self, resolver, out);\n    |                 ^^^^^^^^^^^^^^^ function or associated item cannot be called on `RelPtr<_, ()>` due to unsatisfied trait bounds\n    |\n   ::: src/rel_ptr/mod.rs:267:1\n    |\n267 | pub struct RelPtr<T: ArchivePointee + ?Sized, O> {\n    | ------------------------------------------------ function or associated item `resolve_emplace` not found for this struct\n    |\nnote: trait bound `(): Offset` was not satisfied\n   --> src/rel_ptr/mod.rs:338:37\n    |\n338 | impl<T: ArchivePointee + ?Sized, O: Offset> RelPtr<T, O> {\n    |                                     ^^^^^^  ------------\n    |                                     |\n    |                                     unsatisfied trait bound introduced here\n\nnote: erroneous constant encountered\n  --> src/string/mod.rs:49:27\n   |\n49 |         if value.len() <= repr::INLINE_CAPACITY {\n   |                           ^^^^^^^^^^^^^^^^^^^^^\n\nnote: erroneous constant encountered\n  --> src/string/mod.rs:65:27\n   |\n65 |         if value.len() <= INLINE_CAPACITY {\n   |                           ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0080, E0277, E0282, E0599, E0605.\nFor more information about an error, try `rustc --explain E0080`.\nwarning: `rkyv` (lib) generated 39 warnings\nerror: could not compile `rkyv` (lib) due to 97 previous errors; 39 warnings emitted\n",
      "stdout": ""
    },
    "features": [
      "alloc",
      "std"
    ],
    "project": "../../../Downloads/695-Project/dataset/nostd-failed-crates/crates/rkyv-0.7.44/src",
    "time_to_build": 826,
    "time_to_solve": 703
  }
]