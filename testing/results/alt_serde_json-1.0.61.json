[
  {
    "built_with_features": null,
    "command": {
      "args": [
        "build",
        "--target",
        "thumbv7m-none-eabi",
        "--no-default-features"
      ],
      "code": 101,
      "stderr": "   Compiling alt_serde_json v1.0.61 (/Users/graysonnocera/Downloads/695-Project/dataset/nostd-failed-crates/crates/alt_serde_json-1.0.61)\nerror: expected item, found `\"serde_json requires that either `std` (default) or `alloc` feature is enabled\"`\n --> src/features_check/error.rs:1:1\n  |\n1 | \"serde_json requires that either `std` (default) or `alloc` feature is enabled\"\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nwarning: unused imports: `Cell` and `RefCell`\n   --> src/lib.rs:377:32\n    |\n377 |     pub use self::core::cell::{Cell, RefCell};\n    |                                ^^^^  ^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self`\n   --> src/lib.rs:378:33\n    |\n378 |     pub use self::core::clone::{self, Clone};\n    |                                 ^^^^\n\nwarning: unused import: `self`\n   --> src/lib.rs:379:35\n    |\n379 |     pub use self::core::convert::{self, From, Into};\n    |                                   ^^^^\n\nwarning: unused import: `self`\n   --> src/lib.rs:380:35\n    |\n380 |     pub use self::core::default::{self, Default};\n    |                                   ^^^^\n\nwarning: unused import: `self`\n   --> src/lib.rs:382:32\n    |\n382 |     pub use self::core::hash::{self, Hash};\n    |                                ^^^^\n\nwarning: unused import: `self`\n   --> src/lib.rs:384:34\n    |\n384 |     pub use self::core::marker::{self, PhantomData};\n    |                                  ^^^^\n\nwarning: unused import: `Bound`\n   --> src/lib.rs:385:31\n    |\n385 |     pub use self::core::ops::{Bound, RangeBounds};\n    |                               ^^^^^\n\nwarning: unexpected `cfg` condition name: `no_btreemap_remove_entry`\n   --> src/map.rs:135:51\n    |\n135 |         #[cfg(any(feature = \"preserve_order\", not(no_btreemap_remove_entry)))]\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(no_btreemap_remove_entry)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(no_btreemap_remove_entry)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n    = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `no_btreemap_remove_entry`\n   --> src/map.rs:139:13\n    |\n139 |             no_btreemap_remove_entry,\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(no_btreemap_remove_entry)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(no_btreemap_remove_entry)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `no_btreemap_get_key_value`\n   --> src/map.rs:140:17\n    |\n140 |             not(no_btreemap_get_key_value),\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(no_btreemap_get_key_value)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(no_btreemap_get_key_value)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `no_btreemap_remove_entry`\n   --> src/map.rs:150:13\n    |\n150 |             no_btreemap_remove_entry,\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(no_btreemap_remove_entry)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(no_btreemap_remove_entry)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `no_btreemap_get_key_value`\n   --> src/map.rs:151:13\n    |\n151 |             no_btreemap_get_key_value,\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using a Cargo feature instead\n    = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n             [lints.rust]\n             unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(no_btreemap_get_key_value)'] }\n    = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(no_btreemap_get_key_value)\");` to the top of the `build.rs`\n    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nerror[E0004]: non-exhaustive patterns: `Value::String(_)` not covered\n   --> src/value/de.rs:210:15\n    |\n210 |         match self {\n    |               ^^^^ pattern `Value::String(_)` not covered\n    |\nnote: `Value` defined here\n   --> src/value/mod.rs:111:10\n    |\n111 | pub enum Value {\n    |          ^^^^^\n...\n146 |     String(String),\n    |     ------ not covered\n    = note: the matched value is of type `Value`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n217 ~             Value::Object(v) => visit_object(v, visitor),\n218 ~             Value::String(_) => todo!(),\n    |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1245 |     deserialize_integer_key!(deserialize_i8 => visit_i8);\n     |     ---------------------------------------------------- in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<i8, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1246 |     deserialize_integer_key!(deserialize_i16 => visit_i16);\n     |     ------------------------------------------------------ in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<i16, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1247 |     deserialize_integer_key!(deserialize_i32 => visit_i32);\n     |     ------------------------------------------------------ in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<i32, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1248 |     deserialize_integer_key!(deserialize_i64 => visit_i64);\n     |     ------------------------------------------------------ in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<i64, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1249 |     deserialize_integer_key!(deserialize_u8 => visit_u8);\n     |     ---------------------------------------------------- in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<u8, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1250 |     deserialize_integer_key!(deserialize_u16 => visit_u16);\n     |     ------------------------------------------------------ in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<u16, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1251 |     deserialize_integer_key!(deserialize_u32 => visit_u32);\n     |     ------------------------------------------------------ in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<u32, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1252 |     deserialize_integer_key!(deserialize_u64 => visit_u64);\n     |     ------------------------------------------------------ in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<u64, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1255 |         deserialize_integer_key!(deserialize_i128 => visit_i128);\n     |         -------------------------------------------------------- in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<i128, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n    --> src/value/de.rs:1225:19\n     |\n1225 |             match (self.key.parse(), self.key) {\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(Err(_), alloc::borrow::Cow::Owned(_))` not covered\n...\n1256 |         deserialize_integer_key!(deserialize_u128 => visit_u128);\n     |         -------------------------------------------------------- in this macro invocation\n     |\n     = note: the matched value is of type `(core::result::Result<u128, ParseIntError>, alloc::borrow::Cow<'_, str>)`\n     = note: this error originates in the macro `deserialize_integer_key` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1227 ~                 (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n1228 ~                 (Err(_), alloc::borrow::Cow::Owned(_)) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `alloc::borrow::Cow::Owned(_)` not covered\n    --> src/value/de.rs:1395:15\n     |\n1395 |         match self.value {\n     |               ^^^^^^^^^^ pattern `alloc::borrow::Cow::Owned(_)` not covered\n     |\nnote: `alloc::borrow::Cow<'_, str>` defined here\n    --> /Users/graysonnocera/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/borrow.rs:180:1\n     |\n180  | pub enum Cow<'a, B: ?Sized + 'a>\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n190  |     Owned(#[stable(feature = \"rust1\", since = \"1.0.0\")] <B as ToOwned>::Owned),\n     |     ----- not covered\n     = note: the matched value is of type `alloc::borrow::Cow<'_, str>`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n     |\n1396 ~             Cow::Borrowed(string) => visitor.visit_borrowed_str(string),\n1397 ~             alloc::borrow::Cow::Owned(_) => todo!(),\n     |\n\nerror[E0004]: non-exhaustive patterns: `Value::Object(_)` not covered\n   --> src/value/ser.rs:17:15\n    |\n17  |         match *self {\n    |               ^^^^^ pattern `Value::Object(_)` not covered\n    |\nnote: `Value` defined here\n   --> src/value/mod.rs:111:10\n    |\n111 | pub enum Value {\n    |          ^^^^^\n...\n170 |     Object(Map<String, Value>),\n    |     ------ not covered\n    = note: the matched value is of type `Value`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n22  ~             Value::Array(ref v) => v.serialize(serializer),\n23  ~             Value::Object(_) => todo!(),\n    |\n\nFor more information about this error, try `rustc --explain E0004`.\nwarning: `alt_serde_json` (lib) generated 12 warnings\nerror: could not compile `alt_serde_json` (lib) due to 14 previous errors; 12 warnings emitted\n",
      "stdout": ""
    },
    "features": [
      "std"
    ],
    "project": "../../../Downloads/695-Project/dataset/nostd-failed-crates/crates/alt_serde_json-1.0.61/src",
    "time_to_build": 3417,
    "time_to_solve": 550
  }
]